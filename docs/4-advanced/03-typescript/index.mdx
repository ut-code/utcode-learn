---
title: TypeScript
---

import { SiTypescript } from "react-icons/si";
import typescriptDemoVideo from "./typescript-demo.mp4";
import setupTypeScriptNodeVideo from "./setup-typescript-node.mp4";
import typesPackageVideo from "./types-package.mp4";
import viteTypescriptVideo from "./vite-typescript.mp4";

## JavaScriptとデータ型

次のような関数を考えてみましょう。

```javascript
function formatDate(date) {
  return `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()}`;
}
```

この関数の`date`引数には、どのような値を指定すれば良いでしょうか。答えは、[`Date`オブジェクト](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Date)を指定することです。`formatDate(new Date("2022-01-01"))`は動作しますが、`formatDate("2022-01-01")`はエラーになってしまいます。しかも、エラーが発生するかどうかは実際に実行してみるまでわかりません。

上のような単純なプログラムならこういった問題は起きにくいですが、プログラムの規模が大きくなるにつれ、「どういった値がやりとりされているのか」という情報を把握することが重要になってきます。こういった情報を、**データ型**、あるいは単に**型**と呼びます。

[TypeScript](https://www.typescriptlang.org/)を用いると、プログラム中にデータ型を記述できるようになります。TypeScriptは、Microsoft社によって開発された、JavaScriptに<Term>トランスパイル</Term>して用いられる言語です。

TypeScriptにおける型は、通常`:`の記号に続けて記述します。例えば、先程のプログラムをTypeScriptを用いて書き直すと、次のようになります。引数の部分に型指定が入っているところに注目してください。

```typescript
function formatDate(date: Date) {
  return `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()}`;
}
```

TypeScriptを導入することにより、このプログラムを記述する際に、次のような支援が得られます。

- `date.`と入力されたタイミングで、使用可能なメソッドが全て表示されます
- 誤った型の引数 (動画内では文字列) を指定すると、エラーが表示されるようになります

<video src={typescriptDemoVideo} controls muted />

:::tip[他言語との比較]

C++やJavaなどのプログラミング言語では、型の情報は実行に何らかの影響を与えますが、TypeScriptはJavaScriptにトランスパイルされる言語であり、実行時には型の情報は一切利用されません。

:::

## TypeScriptを使ってNode.jsのプログラムを記述する

TypeScriptを用いてNode.jsのプログラムを作成するには、次の手順に従ってください。

<video src={setupTypeScriptNodeVideo} controls />

まずは、プロジェクトルートに`package.json`を作成します。`npm init`を実行すればよいのでした。

続いて、

```shell
npm install -D typescript
```

を実行し、[typescriptパッケージ](https://www.npmjs.com/package/typescript)をインストールします。`-D`オプションは「開発時のみに使用する」という意思表示になります。`package.json`に記録される方法が少しだけ変わります。

続いて、`main.ts`ファイルを作成します。TypeScriptファイルの拡張子は通常`.ts`です。今回は、

```typescript title="main.ts"
const language: string = "TypeScript";
console.log(`Hello ${language}!`);
```

としました。

TypeScriptファイルの作成が終わったら、<Term>`npx`コマンド</Term>で[TypeScriptパッケージを実行](https://www.typescriptlang.org/docs/handbook/compiler-options.html)し、TypeScriptファイルをJavaScriptファイルにトランスパイルします。パッケージ名と異なり、`tsc`となるので注意しましょう。

```shell
npx tsc main.ts
```

すると、同名のJavaScriptファイルが生成されます。このファイルを実行すれば、通常のJavaScriptとして実行できます。

なお、TypeScript のウェブサイトで提供されている[TS Playground](https://www.typescriptlang.org/play)を用いると、ブラウザ上で TypeScript のコードを記述し、型チェックの結果を確認できます。

## 型を記述できる場所

TypeScriptの型は、関数の引数や戻り値、変数の後に`:`とともに記述できます。

```typescript
// addはnumber型の引数a, bをとりnumber型の値を返す関数
function add(a: number, b: number): number {
  return a + b;
}

// sumはnumber型の変数
let sum: number = add(3, 4);
```

データ型が誤っている場合、TypeScriptはエラーを出力します。

```typescript
sum = "7"; // Type 'string' is not assignable to type 'number'.

add("3", "4"); // Argument of type 'string' is not assignable to parameter of type 'number'.
```

## データ型と値

TypeScriptにおけるデータ型は、その型の値として扱うことのできる全ての値の集合です。TypeScriptは、プログラムの全体を検査し、指定された型から外れた値の入る可能性のある箇所を検出して、エラーを発生させます。

TypeScriptの型には包含関係があり、`T`が`U`の部分集合である場合、つまり、ある型`T`の全ての値が別の型`U`の値でもある場合、`T`は`U`の**部分型**であるといいます。TypeScriptでは、全体集合である`unknown`型から、空集合である`never`型まで、さまざまな部分型が定義されています。

```typescript
// すべて正しい
const a: unknown = 1;
const b: number = 1;
const c: 1 = 1; // 左辺の1はデータ型としての1

// never型には値を代入できない
// const d: never = 1;
```

![TypeScriptのデータ型](./typescript-types.drawio.svg)

:::tip[`any`型]

TypeScriptの標準設定では、型が判明しなかった場合、`any`型が指定されたものとみなされます。`any`型の値には、どんな操作でも許容されます。`any`型の値はどんな型の変数にも代入できますし、`any`型の変数にはどんな値でも代入できます。上の集合のどの部分にも当てはまりません。

```typescript
const strangeValue: any = 1;

// TypeScriptは誤りを検出できないが、実行時にエラーになる
strangeValue.strangeMethod();
```

:::

### 確認問題

JavaScriptで記載された次の関数`repeat`に対し、TypeScriptとして適切と思われる型を追記してください。

```typescript
function repeat(text, times) {
  let result = "";
  for (let i = 0; i < times; i++) {
    result += text;
  }
  return result;
}
```

<Answer title="文字列の繰り返し">

関数 `repeat` は、文字列 `text` を `times` 回繰り返して結合した新しい文字列を返す関数です。したがって、`text` は `string` 型、`times` は `number` 型、戻り値も `string` 型とするのが適切です。

```typescript
function repeat(text: string, times: number): string {
  let result: string = "";
  for (let i: number = 0; i < times; i++) {
    result += text;
  }
  return result;
}
```

</Answer>

## データ型の別名

`type`宣言を用いると、データ型に対して別名を付けられます。

```typescript
type Age = number;

// 変数ageはAge (number) 型
const age: Age = 18;
```

:::tip

型の名前には通常<Term>パスカルケース</Term>が用いられます。

:::

## オブジェクト型

オブジェクト型では、プロパティの名前や、値の型が指定できます。

```typescript
// Studentはstring型のnameプロパティとnumber型のageプロパティを持つオブジェクト
type Student = {
  name: string;
  age: number;
};

let student: Student = { name: "田中", age: 18 };
```

クラス名は、そのまま型名として利用できます。また、フィールドにも型を指定できます。

```typescript
class Student {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

const student: Student = new Student("田中", 18);
```

TypeScriptでは、プロパティが多いオブジェクト型は、プロパティが少ないオブジェクト型の部分型とみなされます。次の例では、プロパティの数が多い`Teacher`オブジェクトを、プロパティの数が少ない`Student`として代入しています。

これは、`Teacher`オブジェクトが`Student`オブジェクトの全てのプロパティを持っており、`Student`オブジェクトに対する全ての操作を安全に実行できるためです。一方で、`Student`オブジェクトを`Teacher`オブジェクトとして代入することはできません。なぜなら、`Student`オブジェクトは`Teacher`オブジェクトが持つ`subject`プロパティを持っていないためです。

```typescript
type Teacher = {
  name: string;
  age: number;
  subject: string;
};

let teacher: Teacher = { name: "鈴木", age: 18, subject: "数学" };
student = teacher;

// Property 'subject' is missing in type 'Student' but required in type 'Teacher'.
teacher = student;
```

### 確認問題

JavaScriptで記載された次のプログラムに対し、TypeScriptとして適切と思われる型を追記してください。

```typescript
class Product {
  name;
  price;
  constructor(name, price) {
    this.name = name;
    this.price = price;
  }
}

class Book extends Product {
  author;
  constructor(name, price, author) {
    super(name, price);
    this.author = author;
  }
}

function calculateTotal(item, quantity) {
  return item.price * quantity;
}

const book = new Book("TypeScript 入門", 2500, "山田 太郎");
const total = calculateTotal(book, 3);
```

<Answer title="商品の合計金額の計算">

- `name`, `price`, `author` はそれぞれ `string`, `number`, `string` 型とするのが適切です。
- `calculateTotal` 関数の引数 `item` は `Product` 型と `Book` 型のいずれも文法的には正しいですが、関数の処理において `Book` 特有のプロパティを使用していないため、`Product` 型を指定するのがより適切です。
- `quantity` は商品の数量を表すため `number` 型とします。戻り値も合計金額を表すため `number` 型とします。

```typescript
class Product {
  name: string;
  price: number;
  constructor(name: string, price: number) {
    this.name = name;
    this.price = price;
    ï;
  }
}

class Book extends Product {
  author: string;
  constructor(name: string, price: number, author: string) {
    super(name, price);
    this.author = author;
  }
}

function calculateTotal(item: Product, quantity: number): number {
  return item.price * quantity;
}

const book: Book = new Book("TypeScript 入門", 2500, "山田 太郎");
const total: number = calculateTotal(book, 3);
```

</Answer>

## 配列型

型`T`の配列型は、`T[]`のように記述できます。また、`T`が`U`の部分型であれば、`T[]`は`U[]`の部分型になります。

```typescript
const numbers: number[] = [1, 2, 3];

// number[]はunknown[]の部分型
const unknowns: unknown[] = numbers;
```

## 関数型

関数型では、引数や戻り値の型が指定できます。引数名は異なっていても同じ型だとみなされます。

```typescript
// BinaryNumberOperatorはnumber型の引数2つを受け取ってnumber型の値を返す関数
type BinaryNumberOperator = (x: number, y: number) => number;

function add(a: number, b: number): number {
  return a + b;
}

const operator: BinaryNumberOperator = add;
```

関数型の部分型の関係は複雑ですが、次の表のように整理できます。

| 種類       | 関係                | 関数型の関係                            |
| ---------- | ------------------- | --------------------------------------- |
| 引数の数   | `f1` < `f2`         | `f1` が `f2` の部分型                   |
| 引数の型   | `T` が `U` の部分型 | `(x: U) => R` が `(x: T) => R` の部分型 |
| 戻り値の型 | `T` が `U` の部分型 | `() => T` が `() => U` の部分型         |

戻り値の型については自然に理解できますが、引数の数や引数の型については直感に反するかもしれません。このような関係になっているのは、関数が受け取る引数が少なかったり、より一般的な型であったりする場合、その関数はより多くの状況で安全に使用できるためです。

```typescript
// 引数の数が少ない関数は、引数の数が多い関数の部分型
type BinaryNumberOperator = (x: number, y: number) => number;
const increment: BinaryNumberOperator = (x) => x + 1;
increment(1, 2); // 第2引数は無視されるので問題ない

// 引数の型がより一般的な関数は、引数の型がより具体的な関数の部分型
type NumberConsumer = (number: number) => unknown;
const logger: NumberConsumer = (number: unknown) => console.log(number);
logger(1); // number型の引数はunknown型として扱えるので問題ない
```

### 確認問題

次の型のうち、`(v: string) => string`型の部分型であるものを全て選んでください。

- `(v1: string, v2: string) => string`
- `() => string`
- `(v: unknown) => string`
- `(v: never) => string`
- `(v: string) => unknown`
- `(v: string) => never`

<Answer>

引数の数は少ないものが、引数の型はより一般的なものが、戻り値はより具体的なものが、部分型となります。

- `() => string`
- `(v: unknown) => string`
- `(v: never) => string`

</Answer>

## 型演算

2 つの型に対し、集合の和や積 (共通部分)を求める記号が利用できます。

| 記号 | 意味     |
| ---- | -------- |
| `&`  | 共通部分 |
| `\|` | 合併     |

次の例では、`Student`型と`Programmer`型の共通部分を持つオブジェクト`studentProgrammer`を定義しています。TypeScriptでは、多くのプロパティを持つオブジェクト型は、少ないプロパティを持つオブジェクト型の部分型とみなされるため、`Student & Programmer`型は、`name`、`major`、`language`の3つのプロパティを持つオブジェクト型と見做されます。

```typescript
type Student = { name: string; major: string };
type Programmer = { name: string; language: string };
const studentProgrammer: Student & Programmer = {
  name: "田中",
  major: "数学",
  language: "TypeScript",
};
```

合併型は、いずれかの型に属する値を表します。次の例では、`Meeting`型は`InPersonMeeting`型か`OnlineMeeting`型のいずれかに属する値を表します。関数`describeMeeting`では、`type`プロパティの値に応じて適切な処理を行っています。

TypeScriptでは、変数が文脈から合併型のどの型に属するかが明らかな場合、その型に応じたプロパティやメソッドが利用可能になります。この例では、`type`プロパティの値が`"in_person"`である場合、`location`プロパティが利用可能であり、`"online"`である場合、`url`プロパティが利用可能であることが分かります。

```typescript
type InPersonMeeting = { type: "in_person"; location: string };
type OnlineMeeting = { type: "online"; url: string };
type Meeting = InPersonMeeting | OnlineMeeting;

function describeMeeting(meeting: Meeting): string {
  if (meeting.type === "in_person") {
    return `会議は ${meeting.location} で行われます。`;
  } else {
    return `会議はオンラインで行われます。URL: ${meeting.url}`;
  }
}
```

### 確認問題

**問題1**: `string & number`型は何型と等しいでしょうか。

**問題2**: 次のように定義される型`T`に対して使用可能なプロパティは何でしょうか。

```typescript
type T = { name: string; age: number } | { name: string; subject: string };
```

<Answer>

**問題1**: `never`型

TypeScriptでは、`string`型と`number`型とも見做せるような値は存在しません。したがって、`string & number`型は空集合である`never`型と等しいです。

**問題2**: `name`のみ

型`T`は、`{ name: string; age: number }`型と`{ name: string; subject: string }`型の合併型です。両方の型に共通して存在するプロパティは`name`のみであるため、型`T`に対して使用可能なプロパティは`name`のみとなります。

</Answer>

## 型推論

文脈からデータ型が明らかな場合は、型定義の記述を省略できます。

```typescript
// ageはnumber型
let age = 18;

// Type 'string' is not assignable to type 'number'.
age = "19";

// 戻り値の型が推論されるため、addは(a: number, b: number) => number型
function add(a: number, b: number) {
  return a + b;
}
```

関数型を要求する部分に関数式を指定する場合、その引数の型が推論されます。

```typescript
type BinaryNumberOperator = (a: number, b: number) => number;

// aやbはnumberに推論される
const operator: BinaryNumberOperator = (a, b) => a + b;

// イベントハンドラの記述の際に便利
window.onload = (e) => {
  // eはEvent型
};
```

## ジェネリクス

引数を一つ受け取り、その値をそのまま返す関数を考えてみよう。

```typescript
function identity(x) {
  return x;
}
```

こういった関数では、引数`x`はどんな型の値も指定できます。つまり、`x`は`unknown`型とするのが適切なはずです。しかし、引数を`unknown`型としてしまうと、戻り値が`unknown`型となってしまい、戻り値に対する操作が一切不可能になってしまいます。

```typescript
function identity(x: unknown) {
  return x;
}

// Object is of type 'unknown'.
identity(1).toString();
```

TypeScriptでは、型パラメータを用いることで、この問題を解決できます。型パラメータは、通常の引数と異なり、型を指定するための特殊な引数です。JavaScriptに<Term>トランスパイル</Term>されるタイミングで削除されます。こういった言語機能は他の多くのプログラミング言語でも用意されており、[ジェネリクス](https://www.typescriptlang.org/docs/handbook/2/generics.html)と呼ばれます。

```typescript
// Tは型パラメータ
// identityはT型の引数を受け取ってT型の戻り値を返す関数
function identity<T>(x: T): T {
  return x;
}

// Tにnumberを指定したので、ここではidentityはnumber型の引数を受け取ってnumber型の戻り値を返す関数
identity<number>(1).toString();

// 文脈から型パラメータが明らかな場合は推論される
// この場合はTはnumberに推論される
identity(1).toString();
```

クラスや`type`宣言でも型パラメータを利用できます。

```typescript
class Range<T> {
  from: T;
  to: T;
  constructor(from: T, to: T) {
    this.from = from;
    this.to = to;
  }
}

const dateRange = new Range<Date>(
  new Date("2022-01-01"),
  new Date("2022-12-31"),
);

type BinaryOperator<T> = (a: T, b: T) => T;

// addは(a: number, b: number) => number型
const add: BinaryOperator<number> = (a, b) => a + b;
```

### 確認問題

次の関数`apply`は、関数を適用する関数です。引数と戻り値を表す型パラメータを定義し、ジェネリクスを用いて適切な型をつけてください。

```typescript
function apply(f, x) {
  return f(x);
}

const result = apply(Math.sqrt, 1024); // resultはnumber型
```

<Answer>

`Math.sqrt`は、`(x: number) => number`型の関数です。したがって、`apply`関数の型パラメータ`T`と`U`は`number`に推論されます。

```typescript
function apply<T, U>(f: (x: T) => U, x: T): U {
  return f(x);
}
```

<ViewSource url={import.meta.url} path="_samples/apply" noCodeSandbox />

</Answer>

## TypeScriptとnpm

npmでインストールしたパッケージがTypeScriptに対応している場合、下の図のように、npmのパッケージのウェブサイトに <SiTypescript style={{ verticalAlign: "text-bottom" }} /> アイコンが表示されます。

![npmパッケージのTypeScript対応](./npm-typescript.png)

`DT`アイコンがついているパッケージは、`@types/パッケージ名`という名称のパッケージをインストールすることで、TypeScriptからパッケージが利用可能になります。例えば、`@types/express`パッケージをインストールすることにより、`express`パッケージがTypeScriptから利用できるようになります。

<video src={typesPackageVideo} controls />

`@types`パッケージのインストール前後で`app`の型が変わっていることが分かります。

## フロントエンドにおけるTypeScriptの利用

Viteは、標準でTypeScriptのトランスパイラが内蔵されています。新しくプロジェクトを作成する際は、テンプレートを選択する際にTypeScriptのテンプレートを使用しましょう。

<video src={viteTypescriptVideo} controls />

:::tip[`tsconfig.json`]

この方法でプロジェクトを作成すると、`tsconfig.json`というファイルが生成されます。TypeScriptは、さまざまなJavaScriptのニーズに合わせてカスタマイズできるようになっており、その設定を記述するためのファイルが`tsconfig.json`です。

[公式ドキュメント](https://www.typescriptlang.org/tsconfig)には、全てのオプションの詳細な説明が記述されています。特に、[`strict`オプション](https://www.typescriptlang.org/tsconfig#strict)は、TypeScriptの能力を大幅に上昇させることができるので、有効にすることが推奨されています。`typescript`パッケージを直接インストールしたプロジェクトでは、`npx tsc --init`コマンドによりこのファイルを生成できます。

:::

## 演習問題

[第3章の「Fetch APIでデータを送信する」節](../../web-servers/fetch-api-post/)のTypeScriptを用いて書き直してみましょう。
