---
title: Cookieと認証（発展）
---

import cookieCounterVideo from "./cookie-counter.mp4";

多くのWebアプリケーションは、利用者が本人であることを確認するための機能を備えています。この節では、Webアプリケーションにおける「ログイン」機能を実装するための、最も基本的な技術要素について学びます。

:::danger
認証やセッション管理は、Webアプリケーションのセキュリティにおいて非常に重要な要素で、この節で学ぶ内容のみでは、実際のアプリケーション向けの実装としては不十分です。[Firebase Authentication](https://firebase.google.com/products/auth)や[Auth0](https://auth0.com/)などの外部サービスを用いることで、強固なセキュリティを手軽に実現できます。また、どうしても外部サービスを利用できない場合は、[Passsport.js](https://www.passportjs.org/)や、[Auth.js](https://authjs.dev/)などのライブラリを利用することを強く推奨します。
:::

## IDとパスワードによる認証

IDとパスワードによる認証は、Webアプリケーションにおいて最も一般的な認証方法です。アプリケーションの利用者は、ID（通常はメールアドレスやユーザー名）とパスワードを入力し、サーバーは、その組み合わせをデータベースに保存されているものと比較し、一致すれば認証が成功したと判断します。

認証に成功するすると、サーバーはクライアントに対し、一時的な「証明書」を発行します。クライアントは、その証明書を次回以降のリクエストに含めることで、認証が成功していることをサーバーに示します。この証明書として、よく用いられるのが**Cookie**です。Cookieとは、ブラウザ内に保存される少量のデータで、一度保存されると、次回以降のリクエストに自動的に含まれるようになります。

![](./basic-flow.drawio.svg)

## Cookieの利用

Cookieは、HTTPリクエストやレスポンスの<Term type="httpHeaderBody">ヘッダ</Term>を用いて送受信します。

レスポンスヘッダに`Set-Cookie`ヘッダを含めることにより、次回以降のリクエストで、クライアントはそのデータをリクエストヘッダの`Cookie`ヘッダに入れて毎回送信します。この性質を利用することで、HTTPサーバーはクライアント毎に異なるサービスを提供できるようになります。

Cookie自体もKey-Valueのデータ構造となっているので、`Set-Cookie`ヘッダを複数回送信することにより、複数のCookieを1つのレスポンスで送信することができます。例として、[Yahoo! Japanのウェブサイト](https://www.yahoo.co.jp/)にアクセスした際に、Yahoo! Japanが送信するCookieの中身を覗いてみましょう。

![Yahoo! JapanのCookie](./yahoo-cookies.png)

このレスポンスヘッダを受けて、ブラウザは次のようなCookieを保存します。

![保存されたCookie](./saved-cookies.png)

ブラウザを更新することで、設定されたCookieが確かにリクエストヘッダの中に含まれて送信されていることがわかります。

![リクエストに付加されたCookie](./sent-cookies.png)

## ExpressでCookieを利用する

Expressを用いてレスポンスヘッダにCookieを付加するには、[`express.Response#cookie`メソッド](https://expressjs.com/ja/api.html#res.cookie)を利用します。また、クライアントからのリクエストの`Cookie`ヘッダを解析するためには、[cookie-parser](https://www.npmjs.com/package/cookie-parser)パッケージを利用します。

```shell
npm install cookie-parser
```

を実行して、パッケージをインストールしましょう。Webサーバーのプログラムは次のようになります。

```javascript title="main.mjs"
import express from "express";
import cookieParser from "cookie-parser";

const app = express();
app.use(cookieParser());

app.get("/", (request, response) => {
  // Cookieの値は文字列なので数値に変換が必要
  const count = parseInt(request.cookies.count) || 0;
  const newCount = count + 1;
  // 変更後の値をレスポンスヘッダに乗せる
  response.cookie("count", newCount.toString());
  response.send(`${newCount}回目のアクセスですね。`);
});

app.listen(3000);
```

[`express.Request#cookies`プロパティ](https://expressjs.com/ja/api.html#req.cookies)には、ブラウザから送信されていたCookieがオブジェクト形式で保存されています。ブラウザで表示させると、更新ボタンが押されるたびに数値が増えていることがわかります。

<video src={cookieCounterVideo} controls muted />

プログラムの流れを整理すると、次の図のようになります。

![プログラムの流れ](./cookie-counter-timeline.png)

### 確認問題

- Chromeの開発者ツールを用いて、リクエストヘッダとレスポンスヘッダの内容を確認してみましょう。
- シークレットモードでページを開くと値はどうなるでしょうか。

## Cookieを用いた認証

ユーザー名とパスワードを用いて認証するタイプのアプリケーションを考えてみましょう。ユーザー名とパスワードを、そのままCookieに入れてしまうと、データが悪意のある第三者に奪われてしまうリスクが高まります。

このため、ログインが成功したタイミングで、クライアントに対してランダムなIDを発行し、Cookieに保存させておくことが一般的です（**セッションID**と呼ばれる）。次回以降のアクセスでは、このセッションIDを用いて認証を行います。このフローを図にすると、次のようになります。

![セッション](./session.png)

### 演習問題

ユーザーが自分のユーザー名とパスワードでログインし、プロフィールを表示できるウェブアプリケーションを作成してみましょう。

`schema.prisma`は次の通りとします。

```javascript title="schema.prisma"
model User {
  id       Int    @id @default(autoincrement())
  username String @unique
  password String
}

model Session {
  id     String @id // 一意でランダムなID
  userId Int // UserのID
}
```
