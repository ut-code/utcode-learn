---
title: オブジェクトの参照
---

## 参照

[オブジェクト](/docs/trial-session/object/)で扱ったように、JavaScript の値はオブジェクトとプリミティブに分けられます。前回は、プリミティブを「それ以上分解できない値」のように説明しました。もう少し詳しくみてみましょう。

![オブジェクトとプリミティブ](../../1-trial-session/11-object/value-types-with-object.drawio.svg)

次のコードを実行してみてください。

```javascript
const object1 = { name: "田中", age: 18 };
const object2 = object1;
object2.age = 19;
document.write(object1.age);
```

<ViewSource url={import.meta.url} path="_samples/reference" />

このプログラムの実行結果は `19` になります。なぜでしょうか。

実は、オブジェクトを生成する式 `{ name: "田中", age: 18 }` は、オブジェクトを生成こそするものの、**式自体の評価結果は、オブジェクトそのものでなく、コンピューターのメモリ上のどこかに存在するオブジェクトの本体の場所を指し示す値になります**。

言い換えれば、JavaScript において、**オブジェクトそのものは値ではありません**。JavaScript の**値として有効なのは、オブジェクトへの参照**なのです。

![参照](./reference.drawio.svg)

これを踏まえて先ほどのコードを見直してみましょう。JavaScript で値として扱えるのは参照のみなので、1 行目で `object1` に代入されるのは、その本体への参照です。

2 行目では、変数 `object1` に代入されている参照が `object2` にコピーされます。これにより、同じオブジェクトを参照する変数が 2 つできます。よって、`object1.age` と `object2.age` は同じものになるのです。

:::tip
上で説明したように、オブジェクトを変数に代入するとき、実際に代入されているのはオブジェクトの**参照**です。

`const` による宣言で禁止されるのはその変数への再代入だけであり、オブジェクトのプロパティの変更は参照を変えないためこれにあたりません。
そのため、`const`で宣言しても、そのプロパティを書き換えることができてしまうので注意しましょう。

```js
const tanaka = { name: "田中", age: 18 };
tanaka.age = 19; // エラーにならず、代入できてしまう
document.write(tanaka.age); // 19 と表示される
```

:::

## ネストされたオブジェクト

オブジェクトの中に別のオブジェクトが格納されている場合を考えてみましょう。

```javascript
const person = {
  name: "田中",
  scores: { math: 80, science: 90 },
};
```

[以前](/docs/trial-session/object/)にも記載した通り、オブジェクトのプロパティ名として使用可能なのは文字列のみですが、プロパティの値としては任意の JavaScript の値が使用できるのでした。

オブジェクトがネストされている場合、次のようにプロパティの値として別のオブジェクトへの参照が格納されていると考えることができます。

![ネストされた参照](./nested-reference.drawio.svg)

## スプレッド構文

参照の仕組みが特に問題になってくる場合として、オブジェクトの参照先が別の関数によって書き換えられる場合があります。次のコードを実行してみましょう。

```javascript
function incrementAge(person) {
  person.age += 1;
  return person;
}

const tanaka = { name: "田中", age: 18 };
const nextYearTanaka = incrementAge(tanaka);
document.write(nextYearTanaka.age);
document.write(tanaka.age); // 19 と表示されてしまう
```

<ViewSource url={import.meta.url} path="_samples/object-mutated-by-function" />

このコードは、[オブジェクト](/docs/trial-session/object/)の項で扱った課題でした。
実はこのコードには問題があり、`tanaka` に対して `incrementAge` を適用すると、関数が適用された `tanaka` にも影響が及んでしまいます。
これは、関数に渡される値はオブジェクトへの参照で、このオブジェクトは呼び出し元の変数が参照するものと同一のものだからです。

オブジェクトの全てのプロパティをコピーして新しいオブジェクトを生成するために、[スプレッド構文](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Spread_syntax)というものを使うことができます。

[スプレッド構文](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Spread_syntax)は、配列やオブジェクトを、別の配列やオブジェクトに展開するための記法です。
オブジェクトを展開した時は、重複するプロパティがある場合は後に記載されたものが優先されます。

```js
const array1 = [1, 2, 3];
const array2 = [...array1, 4, 5]; // [1, 2, 3, 4, 5]

const object1 = { a: 1, b: 2 };
const object2 = { ...object1, b: 3, c: 4 }; // { a: 1, b: 3, c: 4 }
```

## 演習

では、スプレッド構文を使って、オブジェクトの項で扱った課題を、もとのオブジェクトを変更しないように書き換えてみましょう。

```js
function incrementAge(person) {
  ...
}

const tanaka = { name: "田中", age: 18 };
const nextYearTanaka = incrementAge(tanaka);
document.write(nextYearTanaka.age); // 19
document.write(tanaka.age); // 18 と表示されてほしい
```

<Answer title="スプレッド構文">

```js
function incrementAge(person) {
  return { ...person, age: person.age + 1 };
}

const tanaka = { name: "田中", age: 18 };
const nextYearTanaka = incrementAge(tanaka);
document.write(nextYearTanaka.age); // 19
document.write(nextYearTanaka.address); // 東京
```

<ViewSource url={import.meta.url} path="_samples/answer-spread" />

</Answer>
